<html>

<head>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <meta charset="utf-8" />
</head>
<title>Understanding Dynamic Programming using D3</title>
<style>
    path {
        fill: none;
        stroke: #000;
        stroke-width: 3px;
        opacity: 0.2;
    }

    circle {
        fill: steelblue;
        stroke: #fff;
        stroke-width: 3px;
        opacity: 0.4;
    }

    .weight {
        width: 150px;
        margin-left: 15px;
        float: left;
        font-weight: bold;

        color: "Black";
    }

    .box {
      height : 30px;
      width : 50px;
    }

    .controls
    {
      
        width: 150px;
        margin-left: 15px;
        float: left;
        font-weight: bold;
        font-size: 15px;
        color: "Black";
    
    }


</style>
<h4>Understanding Dynamic Programming through Interactive Visualization</h4>
<center>
    <svg id="grid" width="920" height="500"></svg>
    <br/>
</center>    
        <h4>
        <div>Step 1: Select number of rows and columns</div><br/>
        <div class = "rowcol">Number of Rows: <input name = 'rowBox' type="number" min = "1" max="10" value = "1" id = "rowBox" class="box"/> &nbsp
          Number of Columns: <input name = 'colBox' type="number" min = "1" max="10" value = "1" id = "colBox" class ="box"/>&nbsp <input name = 'buildBox' type="submit" maxlength="2" id = "buildBox" value = "Build Grid" onclick = "update()"/> </div> 
        </div> <br/>
        <div>Step 2: Select the start and end point on the Grid</div> <br/>
        <div id ="start" class = "text">You start at :</div> <br/>
        <div id ="end" class = "text">You end at :</div> <br/>
        <div>Step 3: Hit Explore! &nbsp 
        <input name = 'exploreBox' type="submit" maxlength="2" id = "exploreBox" value = "Explore" onclick = "animateRobot()"/> </div> 
      </h4>
  


<body>
    <script>
        var bw = 40;
        var bh = 40;
        var r = 10;
        var c = 10;
        var origin = [0,0];
        var destination = [r-1,c-1];
        
        var points = [
            [20, 180],
            [60, 180],
            [60, 220]
        ];

        var points2 = [
            [20, 180],
            [20, 220]
        ];

        // function to generate random numbers
        function numGenerate(r, c) {
            return Math.round(Math.random() * Math.max(r, c))
        }

        // function to generate the array of points to plot squares

        function gridData(r, c, bw, bh) {
            var data = new Array();
            var xpos = 1; //starting xpos and ypos at 1 so the stroke will show when we make the grid below
            var ypos = 1;
            var click = 0;


            // iterate for rows 
            for (var row = 0; row < r; row++) {
                data.push(new Array());

                // iterate for cells/columns inside rows
                for (var column = 0; column < c; column++) {
                    var wt = numGenerate(r, c)

                    data[row].push({
                        x: xpos,
                        y: ypos,
                        width: bw,
                        height: bh,
                        click: click,
                        weight: wt,
                        r: row,
                        c: column
                    })
                    // increment the x position. I.e. move it over by 50 (width variable)
                    xpos += bw;
                }
                // reset the x position after a row is complete
                xpos = 1;
                // increment the y position for the next row. Move it down 50 (height variable)
                ypos += bh;
            }
            return data;
        }

        var constructed_grid = gridData(r, c, bw, bh);

        // Function to build the grid

        function buildGrid(r, c, bw, bh, gridD) {
            var r = r;
            var c = c;
            var bw = bw;
            var bh = bh;

            var grid = d3.select("svg")
                .append("g")
                .attr("width", ((r * bw) + r) + "px")
                .attr("height", ((c * bh) + c) + "px")
                .attr("transform", "translate(250,0)");

            var row = grid.selectAll(".row")
                .data(gridD)
                .enter().append("g")
                .attr("class", "row");

            var start = false;
            var count = 0;

            var column = row.selectAll(".square")
                .data(function(d) {
                    return d;
                })
                .enter().append("rect")
                .attr("class", "square")
                .attr("x", function(d) {
                    return d.x;
                })
                .attr("y", function(d) {
                    return d.y;
                })
                .attr("width", function(d) {
                    return d.width;
                })
                .attr("height", function(d) {
                    return d.height;
                })
                .attr("weight", function(d) {
                    return d.weight
                })
                .style("fill", "#fff")
                .style("stroke", "#222")
                .attr("text", function(d) {
                    return displayText(d.weight, d.x, d.y)
                })
                .on('click', function(d) {
                    if (count < 2) {
                        if (start == true) {
                            //console.log("End")
                            var endPt = endPoint(d3.select(this.__data__));
                            d3.select(this).style("fill", "green");
                            start = false;

                        } else {
                            //console.log(d3.select(this.__data__))
                            var startPt = startPoint(d3.select(this.__data__));
                            d3.select(this).style("fill", "red");
                            start = true;
                            
                        }
                    }
                    count = count + 1;
                })



            /* .on('click', function(d) {
                 d.click ++;
                 if ((d.click)%4 == 0 ) { d3.select(this).style("fill","#fff"); }
               if ((d.click)%4 == 1 ) { d3.select(this).style("fill","#2C93E8"); }
               if ((d.click)%4 == 2 ) { d3.select(this).style("fill","#F56C4E"); }
               if ((d.click)%4 == 3 ) { d3.select(this).style("fill","#838690"); }
              });*/
            //.on('mouseover',function(d){return displayText(d.weight, d.x, d.y)});
            //.on('mouseover',function(d) {return console.log(d.weight)});


           
            // Function to display text

            function displayText(boxweight, xpos, ypos) {
                var weight = boxweight;
                var xposition = xpos + 20;
                var yposition = ypos + 20;

                var text = grid.append("text")
                    //.attr("text", weight)
                    .text(weight)
                    .attr("id", "weight")
                    .style("color", "black")
                    .attr("transform", "translate(" + xposition + "," + yposition + ")")

            }

            // Robot mechanism
            

        } // end of buildGrid function

        // function to update the canvas
        function update() {
            d3.selectAll('#weight').remove();
            d3.selectAll('.square').remove();
            d3.selectAll('#pathID').remove();
            d3.selectAll('#circleID').remove();

            //d3.selectAll('#grid').remove();
            /*constructed_grid_updated = gridData(r, c, bw, bh);
            var origin = [0, 0];
            var destination = [r - 1, c - 1];
            cost_matrix = findMinCost(constructed_grid, origin, destination)
            var path = findCheapestPath(cost_matrix, origin, destination, constructed_grid); */
            
            var rows = document.getElementById("rowBox").value
            var cols = document.getElementById("colBox").value
            
            constructed_grid = gridData(rows, cols, bw, bh);

            //console.log(constructed_grid)

            buildGrid(rows, cols, bw, bh, constructed_grid);
        }

        // function to display startpoint
        function startPoint(pointData)
        {
          var startX = pointData.node()['r']
          var startY = pointData.node()['c']
          originText = "You start at : " + startX + " , "+ startY 
          document.getElementById("start").innerHTML = originText;
          origin = [startX, startY]
          //console.log(origin)
        }

        function endPoint(pointData)
        {
          var endX = pointData.node()['r']
          var endY = pointData.node()['c']
          destinationText = "You end at : " + endX + " , "+ endY 
          //destination = endX + "," + endY
          document.getElementById("end").innerHTML = destinationText;
          destination = [endX, endY];
        } 

        function findValidNeighbors(cost_matrix, r, c, col) {
            var valid = [];
            i = col[0];
            j = col[1];

            //top
            if ((j - 1) >= 0 && (j - 1) < c && cost_matrix[i][j - 1].visited == false) {
                valid.push([i, j - 1]);
            }

            //bottom
            if ((j + 1) >= 0 && (j + 1) < c && cost_matrix[i][j + 1].visited == false) {
                valid.push([i, j + 1]);
            }

            //left
            if ((i - 1) >= 0 && (i - 1) < r && cost_matrix[i - 1][j].visited == false) {
                valid.push([i - 1, j]);
            }

            //right
            if ((i + 1) >= 0 && (i + 1) < r && cost_matrix[i + 1][j].visited == false) {
                valid.push([i + 1, j]);
            }

            return (valid);
        }

        function findMinCost(grid, origin, destination) {
            //Shortest cost algorithm
            var queue = {};
            var visited = [];
            var r = grid.length;
            var c = grid[0].length;
            var cost_matrix = new Array(r);

            //Fill the grid with infinite cost
            for (var i = 0; i < r; i++) {

                cost_matrix[i] = new Array(c);

                for (var j = 0; j < c; j++) {
                    cost_matrix[i][j] = {
                        "cost": Infinity,
                        "previous": -1,
                        "visited": false
                    };
                }
            }
            //Setting the origin cost as 0
            cost_matrix[origin[0]][origin[1]].cost = 0;
            //Pushing origin into the dict-queue
            queue[0] = [];
            queue[0].push(origin);
            var i = 0;

            while (Object.keys(queue).length != 0) {

                //Getting the minimum dictionary cost
                cost_first = Math.min.apply(null, Object.keys(queue));
                elements = queue[cost_first];
                first = queue[cost_first][0];
                //console.log(cost_first, first);

                //Gettting all valid neighbors
                neighbors = findValidNeighbors(cost_matrix, r, c, first);

                //Updating cost of neighbors
                while (neighbors.length != 0) {
                    neighbor = neighbors.pop();
                    //console.log(neighbor);
                    //Current Cost
                    cost_neighbor = cost_matrix[neighbor[0]][neighbor[1]].cost;
                    //New Cost by adding the previous value
                    new_cost = cost_first + grid[neighbor[0]][neighbor[1]].weight;

                    //If the new cost is less, then update value
                    if (new_cost < cost_neighbor) {
                        //Updating cost and previous value
                        cost_matrix[neighbor[0]][neighbor[1]].cost = new_cost;
                        cost_matrix[neighbor[0]][neighbor[1]].previous = first

                        //Removing old cost
                        if (queue[cost_neighbor] != undefined) {
                            ind = queue[cost_neighbor].indexOf(neighbor);
                            queue[cost_neighbor].splice(ind, 1);

                            //If old cost length is zero, then remove key
                            if (queue[cost_neighbor].length == 0) {
                                delete queue[cost_neighbor];
                            }
                        }

                        //Add neighbor to new cost
                        if (queue[new_cost] == undefined) {
                            queue[new_cost] = [];
                        }
                        queue[new_cost].push(neighbor);
                    }
                }

                //Remove first element
                ind = queue[cost_first].indexOf(first);
                queue[cost_first].splice(ind, 1);
                //console.log(Object.keys(queue), queue[cost_first][0]);

                if (queue[cost_first].length == 0) {
                    delete queue[cost_first];
                }
                //Visited is true
                cost_matrix[first[0]][first[1]].visited = true;
            }
            return cost_matrix;
        }

        
        //var origin = [0,0]
        //var destination = [r - 1, c - 1];
        

        cost_matrix = findMinCost(constructed_grid, origin, destination)

        function pathSvgIndex(col, grid) {
            element = grid[col[0]][col[1]];
            x = element.x + 20;
            y = element.y + 20;

            return [x, y];
        }

        function findCheapestPath(cost_matrix, origin, destination, constructed_grid) {
            var path = [];
            path.unshift(pathSvgIndex(destination, constructed_grid));
            previous = cost_matrix[destination[0]][destination[1]].previous

            while (previous != origin) {
                path.unshift(pathSvgIndex(previous, constructed_grid));
                previous = cost_matrix[previous[0]][previous[1]].previous
            }
            path.unshift(pathSvgIndex(previous, constructed_grid));
            return path;
        }

        var path = findCheapestPath(cost_matrix, origin, destination, constructed_grid);
        //console.log(path)
        // initial grid
        //buildGrid(r, c, bw, bh, constructed_grid);
    </script>



</body>

</html>